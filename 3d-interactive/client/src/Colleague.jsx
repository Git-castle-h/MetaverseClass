/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 ./public/Robot.glb -o ./src/COlleague.jsx 
*/

import React, { useRef,useEffect, useMemo } from 'react'
import { useGLTF, useAnimations,Html} from '@react-three/drei'
import { RigidBody } from '@react-three/rapier';
import { CapsuleCollider } from '@react-three/rapier';
import { Skeleton } from 'three';
import * as THREE from "three"
import { useFrame, useGraph } from '@react-three/fiber';
import { SkeletonUtils } from 'three/examples/jsm/Addons.js';
import { DEG2RAD } from 'three/src/math/MathUtils.js';

export function Colleague({name="noName", animationName="Idle", rotationY=0, position}) {
  const characterHeight = 1.7;
  const capsuleRadius = 0.3;

  const refModel = useRef();
  const refRigid = useRef();

  const group = useRef()
  const { scene,/*nodes,*/ materials, animations } = useGLTF('/Robot.glb')
  const clone = useMemo(()=>SkeletonUtils.clone(scene),[scene]);
  const {nodes} = useGraph(clone);
  const { actions } = useAnimations(animations, refModel)
  return (

    <RigidBody ref={refRigid} colliders={false} position={position}>

      <CapsuleCollider args={[characterHeight/2 - capsuleRadius, capsuleRadius]}/>
      <group ref={refModel} position-y ={-characterHeight/2} dispose={null}>
        <group name="Scene">
          <group name="Armature" translateX={20} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <primitive object={nodes.mixamorigHips} />
            <skinnedMesh name="Alpha_Joints" geometry={nodes.Alpha_Joints.geometry} material={materials.Alpha_Joints_MAT} skeleton={nodes.Alpha_Joints.skeleton} />
            <skinnedMesh name="Alpha_Surface" geometry={nodes.Alpha_Surface.geometry} material={materials.Alpha_Body_MAT} skeleton={nodes.Alpha_Surface.skeleton} />
          </group>
          <Html wrapperClass='character-name'position-y={characterHeight + characterHeight / 13} center>
            {name}
        </Html>
        </group>
      
        <ApplyShadow refTarget={refModel}/>
        <Animation actions={actions} refModel={refModel} refRigid ={refRigid}
        animationName ={animationName} position={position} rotationY={rotationY}/>
      </group>
    </RigidBody>
    

  )
}

function Animation({actions, refModel, refRigid, animationName, position, rotationY}){
  useEffect(()=>{
    const action = actions[animationName]
    action.reset().fadeIn(0.5).play()
    return()=>{
      action.fadeOut(0.5)
    }
  },[animationName]);

  useFrame((state, delta) =>{
    // 회전
     if(refModel.current) {
    const rotateQuarternion=new THREE.Quaternion()
    rotateQuarternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationY)
    refModel.current.quaternion.rotateTowards(rotateQuarternion, DEG2RAD*5)
    }
    // 위치
     if(refRigid.current) {
    const cy=refRigid.current.translation().y
    refRigid.current.setTranslation({ x:position[0], y:cy, z:position[2] });
    }
    });
  
}





function ApplyShadow({refTarget}){
  useEffect(()=>{
    refTarget.current?.traverse((obj)=>{
      if(obj.isMesh){
        obj.castShadow = true;
        obj.receiveShadow =true;
      }
    })
  },[]);
}


useGLTF.preload('/Robot.glb')
