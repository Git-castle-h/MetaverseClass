/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 ./public/Robot.glb -o ./src/COlleague.jsx 
*/

import React, { useRef,useEffect, useMemo } from 'react'
import { useGLTF, useAnimations,Html} from '@react-three/drei'
import { RigidBody } from '@react-three/rapier';
import { CapsuleCollider } from '@react-three/rapier';
import { Skeleton } from 'three';
import * as THREE from "three"
import { useFrame, useGraph } from '@react-three/fiber';
import { SkeletonUtils } from 'three/examples/jsm/Addons.js';
import { DEG2RAD } from 'three/src/math/MathUtils.js';
import { runSpeed, walkSpeed } from './myCharacter';

export function Colleague({talk="", talkLast =false,name="noName", animationName="Idle", rotationY=0, position}) {
  const characterHeight = 1.7;
  const capsuleRadius = 0.3;

  const refModel = useRef();
  const refRigid = useRef();




  const group = useRef()
  const { scene,/*nodes,*/ materials, animations } = useGLTF('/Robot.glb')
  const clone = useMemo(()=>SkeletonUtils.clone(scene),[scene]);
  const {nodes} = useGraph(clone);
  const { actions } = useAnimations(animations, refModel)

  useEffect(()=>{
    refRigid.current.setTranslation({x:position[0],y:position[1],z:position[2]});
  }, []);

  return (

    <RigidBody lockRotations lockTranslations ref={refRigid} colliders={false} /*position={position}*/>

      <CapsuleCollider args={[characterHeight/2 - capsuleRadius, capsuleRadius]}/>
      <group ref={refModel} position-y ={-characterHeight/2} dispose={null}>
        <group name="Scene">
          <group name="Armature" translateX={20} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <primitive object={nodes.mixamorigHips} />
            <skinnedMesh name="Alpha_Joints" geometry={nodes.Alpha_Joints.geometry} material={materials.Alpha_Joints_MAT} skeleton={nodes.Alpha_Joints.skeleton} />
            <skinnedMesh name="Alpha_Surface" geometry={nodes.Alpha_Surface.geometry} material={materials.Alpha_Body_MAT} skeleton={nodes.Alpha_Surface.skeleton} />
          </group>
          <Html wrapperClass='character-name'position-y={characterHeight + characterHeight / 13} center>
            <div  className="name">{name}</div>
            {talk && talkLast && <div className="talk">{talk}</div>}  
          </Html>
        </group>
      
        <ApplyShadow refTarget={refModel}/>
        <Animation actions={actions} refModel={refModel} refRigid ={refRigid}
        animationName ={animationName} position={position} rotationY={rotationY}/>
      </group>
    </RigidBody>
    

  )
}

let bTriggerFocus = false;
window.onfocus = ()=>{
  bTriggerFocus = true;
}

function Animation({actions, refModel, refRigid, animationName, position, rotationY}){
  useEffect(()=>{
    console.log(animationName);
    const action = actions[animationName]
    action.reset().fadeIn(0.5).play()
    return()=>{
      action.fadeOut(0.5)
    }
  },[animationName]);

  useFrame((state, delta) =>{
    // 회전
     if(refModel.current) {
    const rotateQuarternion=new THREE.Quaternion()
    rotateQuarternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationY)
    refModel.current.quaternion.rotateTowards(rotateQuarternion, DEG2RAD*5)
    }
    // 위치
     if(refRigid.current) {
      
      if(bTriggerFocus){
        refRigid.current.setTranslation({x:position[0], y: position[1], z:position[2]});
        setTimeout(()=>{bTriggerFocus =false;},200);
      }else{
    

          // refRigid.current.setTranslation({ x:position[0], y:cy, z:position[2] });
          const t = refRigid.current.translation();
          const cp = new THREE.Vector3(t.x, t.y, t.z)
          const tp = new THREE.Vector3(position[0], position[1], position[2])


          let speed = animationName === "Walk" ?  walkSpeed : (animationName === "Run" ? runSpeed : 0)
          if( speed === 0 && cp.distanceTo(tp) > 0.1) speed = 1
          // console.log(cp.distanceTo(tp));


          const direction = tp.sub(cp).normalize();
          const dx = direction.x * (speed * delta);
          const dy = direction.y * (speed * delta);
          const dz = direction.z * (speed * delta);

          const cx = t.x + dx;
          const cy = t.y + dy;
          const cz = t.z + dz;
          refRigid.current.setTranslation({x: cx, y:cy, z:cz});



        }
      }
    });
  
}



``
function ApplyShadow({refTarget}){
  useEffect(()=>{
    refTarget.current?.traverse((obj)=>{
      if(obj.isMesh){
        obj.castShadow = true;
        obj.receiveShadow =true;
      }
    })
  },[]);
}


useGLTF.preload('/Robot.glb')
