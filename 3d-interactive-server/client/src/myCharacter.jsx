/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 ./public/myCharacter.glb -o ./src/myCharacter.jsx 
*/
import "./CharacterName.css"
import "./Character.css"

import React, { useEffect, useRef,useCallback, forwardRef, useMemo} from 'react';
import { useGLTF, useAnimations, useKeyboardControls, Html } from '@react-three/drei';
import {useControls} from 'leva';
import { CapsuleCollider, RigidBody } from '@react-three/rapier';
import { useFrame, useGraph } from '@react-three/fiber';
import * as THREE from 'three';
import { SkeletonUtils } from "three/examples/jsm/Addons.js";
import { socket } from "./ServerConnector";


/*export*/ function MyCharacter({talk="", talkLast ="false",name="noName", refOrbitControls,...props},refRigid) {
  const refModel = useRef();
  const { scene,/*nodes,*/ materials, animations } = useGLTF('/myCharacter.glb')
  const clone = useMemo(()=> SkeletonUtils.clone(scene),[scene]);
  const {nodes} = useGraph(clone);
  const { actions } = useAnimations(animations, refModel)
  const characterHeight = 2.3;
  const capsuleRadius = 0.3;

  
  // const refRigid = useRef();

  // const animationNames = Object.keys(actions);
  // console.log(animationNames);

  // const {animationName} = useControls({
  //   animationName:{
  //     value:animationNames[0],
  //     options: animationNames
  //   }

  // });
  
  // useEffect(()=>{
  //   const action = actions[animationName];
  //   action.reset().fadeIn(0.5).play();

  //   return()=>{
  //     action.fadeOut(0.5);
  //   }
  // },[animationName]);

  useEffect(()=>{
    refRigid.current.setTranslation({x:props.position[0],y:props.position[1], z:props.position[2]});
  },[]);


  return (
    <RigidBody lockRotations ref={refRigid} colliders={false} /*{...props}*/>
      <CapsuleCollider args={[characterHeight/2 - capsuleRadius, capsuleRadius]}/>
    <group ref={refModel} castShadow /*{...props}*/ dispose={null} position-y={-characterHeight/2}>
    {/* <group ref={refModel} {...props} dispose={null} > */}

      <group name="Scene" >
        <group name="Armature">
          <primitive object={nodes.Hips}/>
          <skinnedMesh name="EyeLeft001" geometry={nodes.EyeLeft001.geometry} material={materials['Wolf3D_Eye.001']} skeleton={nodes.EyeLeft001.skeleton} />
          <skinnedMesh name="EyeRight001" geometry={nodes.EyeRight001.geometry} material={materials['Wolf3D_Eye.001']} skeleton={nodes.EyeRight001.skeleton} />
          <skinnedMesh name="Wolf3D_Glasses001" geometry={nodes.Wolf3D_Glasses001.geometry} material={materials['Wolf3D_Glasses.001']} skeleton={nodes.Wolf3D_Glasses001.skeleton} />
          <skinnedMesh name="Wolf3D_Hair001" geometry={nodes.Wolf3D_Hair001.geometry} material={materials['Wolf3D_Hair.001']} skeleton={nodes.Wolf3D_Hair001.skeleton} />
          <skinnedMesh name="Wolf3D_Head001" geometry={nodes.Wolf3D_Head001.geometry} material={materials['Wolf3D_Skin.001']} skeleton={nodes.Wolf3D_Head001.skeleton} />
          <skinnedMesh name="Wolf3D_Outfit_Bottom001" geometry={nodes.Wolf3D_Outfit_Bottom001.geometry} material={materials['Wolf3D_Outfit_Bottom.001']} skeleton={nodes.Wolf3D_Outfit_Bottom001.skeleton} />
          <skinnedMesh name="Wolf3D_Outfit_Footwear001" geometry={nodes.Wolf3D_Outfit_Footwear001.geometry} material={materials['Wolf3D_Outfit_Footwear.001']} skeleton={nodes.Wolf3D_Outfit_Footwear001.skeleton} />
          <skinnedMesh name="Wolf3D_Outfit_Top001" geometry={nodes.Wolf3D_Outfit_Top001.geometry} material={materials['Wolf3D_Outfit_Top.001']} skeleton={nodes.Wolf3D_Outfit_Top001.skeleton} />
          <skinnedMesh name="Wolf3D_Teeth001" geometry={nodes.Wolf3D_Teeth001.geometry} material={materials['Wolf3D_Teeth.001']} skeleton={nodes.Wolf3D_Teeth001.skeleton} />
        </group>
        <Html wrapperClass='character-name' position-y={characterHeight + characterHeight / 13} center>
          <div className="name">{name}</div>
          {talk && talkLast && <div className="talk">{talk}</div>}  
        </Html>
      </group>
      <ApplyShadow refTarget={refModel}/>
      <UpdateFrame actions={actions} refModel={refModel} refRigid={refRigid} refOrbitControls={refOrbitControls}/>
    </group>
    </RigidBody>
  )
}


function ApplyShadow({refTarget}){
  useEffect(()=>{
    refTarget.current?.traverse((obj)=>{
      if(obj.isMesh){
        obj.castShadow = true;
        obj.receiveShadow =true;
      }
    })
  },[]);
}


export const walkSpeed =1;
export const runSpeed =3;

function UpdateFrame({actions,refModel,refRigid, refOrbitControls}){
  
  const[/* subscribeKeys*/, getKeys] = useKeyboardControls();

  const refPlayingActionName = useRef();
  const playAction = useCallback((actionName)=>{
    if(refPlayingActionName.current === actionName) return;

    const action = actions[actionName]
    const prevAction = actions[refPlayingActionName.current];

    action.reset().fadeIn(0.5).play();
    prevAction?.fadeOut(0.5);
    refPlayingActionName.current = actionName;
  
  },[]);

  
const refSpeed = useRef(0);
const refExceedTime = useRef(0);

  useFrame((state, delta)=>{
    const keys = getKeys();
    // console.log(keys);


    if(keys.forward || keys.leftward || keys.rightward || keys.backward){
      if(keys.walk){
        playAction("Walk");
        refSpeed.current = walkSpeed;
      }else if(keys.jump){
        playAction("Jump");
      }else if(keys.capoeira){
        playAction("Capoeira");
      }else{
        playAction("Run");
        refSpeed.current = runSpeed;
      }
    }
    else if(keys.jump){
      playAction("Jump");
      
    }
    else if(keys.capoeira){
      playAction("Capoeira");
    }
    else{
      playAction("Idle");
      refSpeed.current =0;
    }

    const camera = state.camera;
    const model = refModel.current;
    const modelPostition = new THREE.Vector3();
    model.getWorldPosition(modelPostition);
    const angleCameraDirectionAxisY = Math.atan2(
      camera.position.x - modelPostition.x,
      camera.position.z - modelPostition.z
    ) + Math.PI;
    
    const rotateQuarternion = new THREE.Quaternion();
    // rotateQuarternion.setFromAxisAngle(new THREE.Vector3(0,1,0), angleCameraDirectionAxisY + getDirectionOffset(keys));
    const rotationY = angleCameraDirectionAxisY + getDirectionOffset(keys);
    rotateQuarternion.setFromAxisAngle(new THREE.Vector3(0,1,0),rotationY);
    model.quaternion.rotateTowards(rotateQuarternion, THREE.MathUtils.degToRad(5));

    const walkDirection = new THREE.Vector3();
    camera.getWorldDirection(walkDirection);
    walkDirection.y = 0;
    walkDirection.normalize();
    walkDirection.applyAxisAngle(new THREE.Vector3(0,1,0), getDirectionOffset(keys));
    const dx = walkDirection.x * (refSpeed.current * delta);
    const dz = walkDirection.z * (refSpeed.current * delta);

    if(refRigid.current){
      const cx = refRigid.current.translation().x + dx;
      const cy = refRigid.current.translation().y ;
      const cz = refRigid.current.translation().z + dz;
      refRigid.current.setTranslation({x:cx, y:cy, z:cz});

      camera.position.x += dx;
      camera.position.z += dz;
      if(refOrbitControls.current){
        refOrbitControls.current.target.set(cx,cy,cz);
      }

      refExceedTime.current += delta;
      if(refExceedTime.current > (.2)){
        socket.emit("update",{
          animationName : refPlayingActionName.current,
          position: [cx,cy,cz],
          rotationY: rotationY
        })
        refExceedTime.current =0;
      }

    }



  });

  const getDirectionOffset = useCallback((keys)=>{
    let directionOffset = 0;
    if(keys.forward){
      if(keys.leftward){
        directionOffset = Math.PI/4;
      }else if (keys.rightward){
        directionOffset = - Math.PI/4;
      }
    } else if(keys.backward){
      if(keys.leftward){
        directionOffset = Math.PI/4+Math.PI/2;
      }else if(keys.rightward){
        directionOffset = - Math.PI/4 - Math.PI/2;
      }else{
        directionOffset = Math.PI;
      }
    } else if(keys.leftward){
      directionOffset = Math.PI / 2;
    } else if(keys.rightward){
      directionOffset = -Math.PI / 2;
    }
    return directionOffset
  },[]);
  

}

export default forwardRef(MyCharacter);

useGLTF.preload('/myCharacter.glb')
